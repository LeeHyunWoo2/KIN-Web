import {DocsImage} from '../../components/docs/Image';
import dimg from "../../lib/docsImages";
import {Tabs} from 'nextra/components'

# 인프라 아키텍처

<p className="text-lg text-gray-600 mt-2">애플리케이션 각 구성 요소 및 인프라 관계를 시각적으로 나타낸 자료를 포함하고 있습니다.</p>

  - 해당 앱을 서비스하기 위해 구성한 모든 인프라가 Cloud 환경에서 동작합니다.
  - 이 카테고리의 이후 문서는 각 인프라의 간단한 소개와, 선택한 이유, 주요 데이터 흐름을 정리합니다.

<br/>

<Tabs items={['다이어그램', '이미지']}>
  <Tabs.Tab><DocsImage src={dimg.architecture.diagram}/></Tabs.Tab>
  <Tabs.Tab><DocsImage src={dimg.architecture.image}/></Tabs.Tab>
</Tabs>

<br/>
<span className="flex justify-center">각 인프라간의 관계를 표현하는 이미지와 다이어그램</span>

<br/>
<br/>

[//]: # ()
[//]: # (## ❌ 왜 express-session을 사용하지 않았는가?)

[//]: # ()
[//]: # (많은 Express 기반 백엔드에서는 인증을 위해 `express-session`과 같은 세션 미들웨어를 사용하는 것이 일반적입니다.)

[//]: # (저 또한 프로젝트 초기에는 이를 고려했고, 실제로 Redis 세션 저장소를 사용하는 방식도 검토했습니다.)

[//]: # ()
[//]: # (그러나 제 서비스 아키텍처와 환경을 종합적으로 고려한 결과,)

[//]: # (**`express-session`대신 JWT + Redis 기반의 인증 구조를 채택하는 것이 더 적합하다**는 결론을 내렸습니다.)

[//]: # ()
[//]: # (---)

[//]: # ()
[//]: # (### 🧠 판단 근거)

[//]: # ()
[//]: # (| 항목 | 이유 |)

[//]: # (|------|------|)

[//]: # (| **서버 부하** | `express-session`은 세션 상태를 서버가 직접 관리하므로 메모리 부하 발생 &#40;전체 RAM 1GB&#41; |)

[//]: # (| **수평 확장성 고려** | 만약 서버 인프라를 증설 한다고 가정해보면? 모든 서버에 동기화 필요 → 병목이 더 발생할것으로 예상됨 -> stateless 방식이 더 유리 |)

[//]: # (| **세션 대체 가능** | Access Token으로 인증처리, Refresh Token은 Redis에 저장하여 블랙리스트 및 만료 제어 가능 |)

[//]: # (| **프론트엔드 구조** | SPA&#40;React + Next.js&#41;인 이 프로젝트에는 `axios`로 토큰을 주고받는 방식이 더 자연스러움 |)

[//]: # ()
[//]: # (---)

[//]: # ()
[//]: # (### ✅ 선택한 구조의 특징)

[//]: # ()
[//]: # (- 서버가 인증 상태를 기억하지 않기 때문에, 모든 API는 독립적으로 동작 가능합니다.)

[//]: # (- Redis를 통해 Refresh Token 제어, 로그아웃 처리, 블랙리스트 관리 등 세션의 역할을 처리할 수 있습니다.)

[//]: # ()
[//]: # ()
[//]: # (---)

[//]: # ()
[//]: # (## 🧠 판단 근거)

[//]: # ()
[//]: # (| 항목 | `express-session &#40;with Redis&#41;` | `JWT + Redis &#40;Stateless 인증&#41;` |)

[//]: # (|------|-----------------------------|-----------------------------|)

[//]: # (| **서버 확장성** | Redis가 중앙 세션 저장소 역할을 하지만, 모든 요청마다 Redis 조회 필요 → 부하 증가 | 대부분의 요청은 Redis 접근 없음 → 수평 확장에 유리 |)

[//]: # (| **인증 상태 위치** | 서버 &#40;Redis&#41;에서 상태 유지 | 클라이언트가 토큰 보유 &#40;Stateless&#41; |)

[//]: # (| **세션 조회 비용** | 모든 요청 시 Redis 조회 필요 | 토큰 검증만으로 인증 완료 &#40;jwt.verify&#41; |)

[//]: # (| **Refresh 관리** | TTL로만 제어 가능, 블랙리스트 구현 복잡 | Redis를 활용한 Refresh Token 무효화 및 블랙리스트 구현 용이 |)

[//]: # (| **보안 옵션** | CSRF 보호 필요, 쿠키 위주 흐름 | HTTPS + HttpOnly + SameSite=Strict 설정으로 안전한 쿠키 기반 JWT 사용 |)

[//]: # (| **프론트엔드 호환성** | SSR 또는 전통적인 웹에 적합 | SPA + 서버리스 환경과 매우 잘 맞음 &#40;Next.js + Vercel&#41; |)

[//]: # ()
[//]: # (---)

[//]: # ()
[//]: # (## 🔧 제 서비스 아키텍처와의 궁합)

[//]: # ()
[//]: # (| 구성 요소 | 설명 |)

[//]: # (|-----------|------|)

[//]: # (| **백엔드 서버** | Oracle Cloud VM에서 Express.js로 구동 |)

[//]: # (| **프론트엔드** | Vercel에서 서버리스 형태로 배포된 Next.js |)

[//]: # (| **클라이언트** | 브라우저 기반 SPA, 토큰은 HttpOnly 쿠키로 관리 |)

[//]: # (| **프로토콜** | HTTPS 기반, SameSite 설정으로 CSRF 방지 |)

[//]: # (| **인증 흐름** | 로그인 시 access/refresh 토큰을 쿠키에 설정 → access는 자체 verify, refresh는 Redis 기반 검증 및 TTL 갱신 |)

[//]: # ()
[//]: # (이러한 구조에서는 서버가 상태를 유지하지 않고도 안정적이고 확장 가능한 인증 흐름을 구성할 수 있습니다.)

[//]: # ()
[//]: # (---)

[//]: # ()
[//]: # (## 🔐 Redis는 왜 도입했는가?)

[//]: # ()
[//]: # (일반적인 JWT 구조의 단점 중 하나는 "Refresh Token을 무효화하거나 회수할 방법이 없다"는 것입니다.)

[//]: # (이를 해결하기 위해 **Refresh Token을 Redis에 저장**하고 다음을 가능하게 했습니다:)

[//]: # ()
[//]: # (- 블랙리스트 관리 &#40;로그아웃, 탈취 대응&#41;)

[//]: # (- TTL 기반 자동 만료 및 재발급 제어)

[//]: # (- rememberMe 기능에 따라 만료 시점 동적 제어)

[//]: # ()
[//]: # (이처럼 Redis는 세션 저장소가 아닌, **보안 강화 및 인증 흐름 제어를 위한 전략적 도구**로 사용되었습니다.)

[//]: # ()
[//]: # (---)

[//]: # ()
[//]: # (## ✅ 선택한 구조의 특징 요약)

[//]: # ()
[//]: # (- 모든 API는 **Stateless하게 동작**하며, 서버 간 인증 상태 공유가 필요 없습니다.)

[//]: # (- 프론트엔드와의 궁합이 뛰어납니다 &#40;SPA 구조에서 axios 기반 쿠키 전송 인증&#41;.)

[//]: # (- Refresh Token의 저장 및 만료는 Redis에서 관리되어 보안이 강화되었습니다.)

[//]: # (- 서버 확장에 유리하고, 인증 요청 처리 속도가 빠릅니다.)

[//]: # ()
[//]: # (---)

[//]: # ()
[//]: # (## 📌 결론)

[//]: # ()
[//]: # (**"세션 기반 인증도 Redis를 쓴다면 차이가 없지 않나요?"** 라는 질문에 대해)

[//]: # (진짜 핵심은 **"인증 상태를 어디에 저장하느냐"**입니다.)

[//]: # ()
[//]: # (- 세션 방식은 **서버가 사용자 상태를 보관**하고 Redis를 반드시 경유해야 합니다.)

[//]: # (- JWT 방식은 **클라이언트가 인증 상태를 보유**하고, 서버는 최소한의 Redis만 활용합니다.)

[//]: # ()
[//]: # (> 즉, Redis를 쓴다고 해서 그것이 곧 세션 기반 인증인 것은 아닙니다.)

[//]: # (> 인증 상태의 주체가 서버인지, 클라이언트인지를 구분해야 합니다.)

[//]: # ()
[//]: # (이 프로젝트는 그러한 원칙 하에, **보안·성능·확장성**을 모두 고려하여)

[//]: # (JWT + Redis 구조를 채택하였습니다.)

[//]: # ()
[//]: # ()
[//]: # (## ❌ 왜 `express-session`을 사용하지 않았는가?)

[//]: # ()
[//]: # (많은 Express 기반 백엔드에서는 인증을 위해 `express-session`과 같은 세션 미들웨어를 사용하는 것이 일반적입니다.  )

[//]: # (저 또한 프로젝트 초기에는 이를 고려했고, 실제로 Redis 세션 저장소를 사용하는 방식도 검토했습니다.)

[//]: # ()
[//]: # (그러나 제 서비스 아키텍처와 기술 요건을 종합적으로 고려한 결과,  )

[//]: # (**`express-session`을 사용하지 않고 JWT + Redis 기반의 인증 구조를 채택하는 것이 더 적합하다**는 결론을 내렸습니다.)

[//]: # ()
[//]: # (---)

[//]: # ()
[//]: # (## 🧠 판단 근거: JWT + Redis vs express-session &#40;with Redis&#41;)

[//]: # ()
[//]: # (| 항목 | `express-session &#40;with Redis&#41;` | `JWT + Redis &#40;Stateless 인증&#41;` | 상세 설명 |)

[//]: # (|------|-----------------------------|-----------------------------|------------|)

[//]: # (| **서버 확장성** | Redis가 중앙 세션 저장소 역할을 하지만, 모든 요청마다 Redis 조회 필요 → 부하 증가 | 대부분의 요청은 Redis 접근 없음 → 수평 확장에 유리 | 세션 기반은 클라이언트 상태를 Redis에 저장하므로 서버가 모든 요청마다 Redis에 접근해야 함. 반면 JWT는 토큰만으로 인증 처리 가능하여 서버 간 공유 필요 없음. |)

[//]: # (| **인증 상태 위치** | 서버 &#40;Redis&#41;에 상태 저장 | 클라이언트가 JWT 토큰을 보유 | 세션 ID를 통해 서버가 상태 추적. JWT는 클라이언트가 인증 정보를 소지하고 서버는 verify만 수행. |)

[//]: # (| **세션 조회 비용** | 모든 요청마다 Redis 접근 | Redis 접근 없음 &#40;대부분의 요청&#41; | 세션 방식은 사용자 수 증가 시 Redis 부하 커짐. JWT는 verify만 하므로 빠르고 안정적. |)

[//]: # (| **Refresh 관리** | TTL 제어만 가능, 즉시 무효화 어려움 | Redis에서 refresh token 관리 + 블랙리스트로 정밀 제어 가능 | JWT 방식에서는 Redis를 통해 refresh token의 TTL 관리, 블랙리스트 처리, rememberMe 제어 등이 가능함. |)

[//]: # (| **보안 옵션** | CSRF 보호 필요, 쿠키 위주 흐름 | HTTPS + HttpOnly + SameSite=Strict 설정으로 안전한 쿠키 기반 토큰 사용 | 세션은 CSRF 방어가 필수이나, JWT 쿠키 방식은 HTTPS와 SameSite 옵션으로 안전하게 구성 가능. |)

[//]: # (| **프론트엔드 호환성** | SSR 또는 전통적인 HTML form 기반 구조에 적합 | SPA 구조와 자연스럽게 맞물림 &#40;Next.js, React, axios 등&#41; | 세션은 form 기반 SSR에서 쿠키가 자동 포함되어 작동이 쉬움. JWT는 SPA에서 axios 요청과의 궁합이 좋고, 서버리스 환경에 적합. |)

[//]: # ()
[//]: # (---)

[//]: # ()
[//]: # (## ✨ 각 항목에 대한 기술적 배경 설명)

[//]: # ()
[//]: # (### ✅ 왜 세션은 SSR에 적합한가?)

[//]: # (- SSR&#40;서버사이드 렌더링&#41;은 요청마다 서버가 HTML을 생성하고 유저에게 응답함)

[//]: # (- 세션은 서버가 상태를 갖고 있기 때문에 "로그인한 사용자에 맞게 렌더링"이 자연스럽게 가능)

[//]: # (- 브라우저가 세션 쿠키를 자동으로 보내기 때문에 별도 로직이 필요 없음)

[//]: # ()
[//]: # (### ✅ 왜 JWT + Redis는 SPA에 적합한가?)

[//]: # (- SPA는 HTML을 클라이언트에서 렌더링하고, API만 서버에 요청함)

[//]: # (- JWT는 클라이언트가 들고 있으므로 매 요청마다 헤더/쿠키로 전송 가능 → API 구조에 맞음)

[//]: # (- 서버리스 환경에서도 상태 공유 없이 동작 가능 → 확장성 뛰어남)

[//]: # ()
[//]: # (### ✅ Refresh Token을 Redis에 저장하는 이유)

[//]: # (- access token은 보안상 수명이 짧아야 하고, refresh token은 재발급을 위한 수단이지만 탈취 위험 존재)

[//]: # (- Redis에 저장함으로써:)

[//]: # (- 로그아웃 시 즉시 무효화 가능)

[//]: # (- rememberMe 여부에 따른 TTL 조정 가능)

[//]: # (- 블랙리스트 관리 가능 → 세션처럼 서버 제어 가능)

[//]: # ()
[//]: # (---)

[//]: # ()
[//]: # (## ✅ 선택한 구조의 특징 요약)

[//]: # ()
[//]: # (- 모든 API는 **Stateless하게 동작**하며, 서버 간 인증 상태 공유가 필요 없습니다.)

[//]: # (- 프론트엔드와의 궁합이 뛰어납니다 &#40;SPA 구조에서 axios 기반 쿠키 전송 인증&#41;.)

[//]: # (- Refresh Token의 저장 및 만료는 Redis에서 관리되어 보안이 강화되었습니다.)

[//]: # (- 서버 확장에 유리하고, 인증 요청 처리 속도가 빠릅니다.)

[//]: # ()
[//]: # (---)

[//]: # ()
[//]: # (## 📌 결론)

[//]: # ()
[//]: # (**Redis를 쓴다고 해서 그것이 곧 세션 기반 인증인 것은 아닙니다.**  )

[//]: # (**인증 상태의 주체가 서버인지, 클라이언트인지를 구분해야 합니다.**)

[//]: # ()
[//]: # (> 이 프로젝트는 그러한 원칙 하에, **보안·성능·확장성**을 모두 고려하여  )

[//]: # (> JWT + Redis 구조를 채택하였습니다.)

[//]: # ()

<br/>