import { Callout } from 'nextra/components'

# ⛔ 이슈 5 : 로그인 성공 후 로그인 실패 - 인증 쿠키 유실

<Callout emoji="⚠️">
  이 문서는 이전 문서 [(보안에 따른 제약)](/docs/issues/issue4#-원인과-제약-분석) 와 비슷해 보일 수 있으나, 전혀 다릅니다!!!
</Callout>

두 이슈는 모두 **인증 장애와 쿠키 관련 언급이 나와** 헷갈릴 수 있지만, 이런 차이점이 있습니다.

- **이전 문제(보안 정책 제약)**
    - OAuth 리다이렉트 방식과 HttpOnly 쿠키 보안 정책 충돌
    - **클라이언트가 유저 정보를 가져올 수 없음**
    - 대상 : 소셜 로그인
    - 과정 : 원인을 찾는건 매우 쉬웠으나, 해결방안을 찾는게 어려웠음

- **이번 문제(API 라우트 문제)**
    - 프론트엔드 서버가 백엔드 서버의 `Set-Cookie` 헤더를 제대로 전달하지 않음
    - **로그인 성공 후에도 인증 상태가 유지되지 않음**
    - 대상 : 일반 로그인
    - 과정 : 원인을 찾는게 매우 어려웠으나, 해결방안은 간단했음

이 문서에서는 **API 라우트 변경이 로그인 인증 흐름에 미친 영향과 해결 방법**을 다룹니다.

---



### 📝 **상황 설명**

- 클라이언트에서 로그인 API 호출 시 정상 코드(`200 OK`)를 반환받음. (올바른 id/pw 입력 시에만)
- 이후 리다이렉트되는 `loginSuccess` 페이지에서 `notes` 가 아니라 `login` 페이지로 리다이렉트 함
- `loginSuccess` 페이지는 로그인 성공 시 백엔드 서버에 세션 유효성 검증을 받는 역할을 함. 세션 검증에 실패했다는 의미.
- 즉, 백엔드가 로그인 성공이라고 판단했지만, 바로 다음 요청에서 백엔드가 실패라고 하는 상황 -> 로그인 성공 후 로그인 실패
- <span className="text-red-500 font-bold text-lg ml-1 mr-3">이 와중에 소셜 로그인은 잘됨</span>

---

### 🔍 **원인 분석**


- **키카드** : 이 문제는 보안을 강화하고자 (API 라우트와 헤더관련 문서 링크하기) Next.js 의 **API 라우트를 도입한 이후**에 발생한것으로 추측됨.

1. **클라이언트 요청 흐름 로깅**
      - 우선 Vercel(프론트엔드 호스팅 플랫폼)의 Logs를 통해 헤더를 검토하였고, **클라이언트 요청이 프론트엔드 서버로** 도달할 때 쿠키가 포함되어 있음을 확인.
      - 이후 프론트엔드 서버에서 백엔드 서버로 전달되는 헤더를 상세히 로깅하여 문제의 원인을 추적. 이 과정에서 `Cookie`가`undefined`로 출력됨.
      - **프론트엔드 서버 → 백엔드 서버** 과정에서 발생한 이슈인것으로 범위 축소됨.

2. **프론트엔드 요청 로깅하기**
    - 백엔드에서 반환하는 응답을 찍어보니, `Set-Cookie` 헤더가 정상적으로 포함되어 있었음.
    - 별도의 필터 로직을 추가한적이 없기 때문에  조금 혼란스러웠으나, 프론트엔드 -> 클라이언트 로깅을 진행.
    - API 라우트에서 이를 클라이언트로 전달하지 않고 **`response.data`만** 반환하고 있었음.
    - 즉, API 라우트가 백엔드의 응답을 가공하는 과정에서 **쿠키 정보가 날아가버린 것**.

3. **해결방안은 간단한데, 원인을 찾는 과정이 어렵다**
    - `loginSuccess` 페이지를 통해 동일한 과정을 거치게 개선한 상태라서 소셜 로그인은 잘되는게 **오히려 헷갈리게 함**
    - 브라우저 네트워크 패널에서 응답을 비교하면서 겨우 쿠키가 사라지는곳이 API 라우트 내부였다는 사실을 찾아냄.
    - "API 라우트를 만들때 따로 필터를 지정한적이 없으니까 백엔드의 응답이 그대로 반환될것이다." <br/> 라는 **고정관념을 가지는 바람에** 시야가 좁아지면서 디버깅이 늦어짐.

4. 소셜 로그인은 잘 되는 이유
    - 소셜 로그인은 클라이언트, 플랫폼, 백엔드가 다이렉트로 연결되는 구조인데, 여기에 중간서버가 껴서 프록싱을 거치면 흐름이 끊김 (프록싱 관련 문서 링크하기)
    - 그래서 임시로 보안처리를 하고 직접 연결되게 두었기 때문에 쿠키 전달에 성공한것

---

### 🛠️ **해결 방안**

1. **API 라우트에서 응답 헤더를 그대로 클라이언트로 전달하도록 수정**
- 기존에는 `res.json(response.data)`로 응답을 반환했으나, 이렇게 하면 쿠키 정보가 포함되지 않음.
- 따라서 **백엔드에서 받은 응답 헤더를 그대로 클라이언트로 전달하도록 코드 수정**.

```jsx filename="[...path].js" {2} copy
  Object.entries(response.headers).forEach(([key, value]) => {
    res.setHeader(key, value);
  });

  res.status(response.status).send(response.data);
```

2. **수정 후 쿠키가 정상적으로 전달되는지 확인**
- 브라우저 개발자 도구에서 로그인 후 응답을 확인하니, `Set-Cookie` 헤더가 정상적으로 전달됨.
- 이후 요청에서도 인증 쿠키가 유지되면서 로그인 상태가 정상적으로 유지됨.

---

### ✅ **결과**

- 로그인 성공 후 인증이 풀리는 문제가 해결됨.
- API 라우트가 쿠키를 누락하는 문제였고, `setHeader`를 사용하여 이를 해결했음.
- **문제의 원인을 찾는 것이 어려웠지만, 해결 자체는 매우 간단했음**.
- 이전 문제(보안 정책 문제)와는 정반대의 상황이 발생한 것이 흥미로운 포인트였음.

---

### 💡 **배운 점**

1. **문제 해결에서 "원인을 찾는 과정"과 "해결 과정"은 항상 난이도가 같지 않다**
    - 이전 문제(보안 정책 제약)는 원인은 쉽게 알았지만 해결이 어려웠음.
    - 이번 문제(API 라우트 쿠키 증발)는 원인을 찾는 게 어려웠지만 해결은 간단했음.
    - 즉, **비슷한 로그인 문제처럼 보이지만, 실제로는 정반대의 해결 과정을 거쳤음**.
    - 다르게 생각해본다면, 비슷한 증상이 발생해도 **원인이 어디에 있을지는 알 수 없다.**<br/> "당연히 그 부분은 잘 되겠지" 같은 생각은 지양해야 한다.

2. **API 라우트가 응답을 가공할 때, 헤더 정보도 신경 써야 한다**
    - `res.json(response.data)`로 응답을 반환하는 경우, `Set-Cookie` 같은 중요한 헤더가 누락될 수 있음.
    - 특히, 로그인 및 인증과 관련된 API는 **헤더까지 그대로 전달해야 문제가 발생하지 않음**.

3. **디버깅 과정에서 브라우저 개발자 도구(Network 탭)를 적극적으로 활용해야 함**
    - 로그만 확인했을 때는 문제가 보이지 않았지만,
    **네트워크 패널에서 응답 헤더를 비교하는 과정에서 원인을 찾아낼 수 있었음**.