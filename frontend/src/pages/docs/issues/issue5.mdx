import { Callout } from 'nextra/components'

# ⛔ 이슈 5 : 로그인 성공 후 로그인 실패 - 인증 쿠키 유실

<Callout emoji="⚠️">
  이 문서는 이전 문서 [(보안에 따른 제약)](/docs/issues/issue4#-원인과-제약-분석) 와 비슷해 보일 수 있으나, 전혀 다릅니다!!!
</Callout>

두 이슈는 모두 **인증 장애와 쿠키 관련 언급이 나와** 헷갈릴 수 있지만, 이런 차이점이 있습니다.

- **<span className="text-red-600">이전</span> 문제(보안 정책 제약)**
    - <p className="-mt-4">OAuth 리다이렉트 방식과 HttpOnly 쿠키 보안 정책 충돌</p>
    - **클라이언트가 유저 정보를 가져올 수 없음**
    - 대상 : 소셜 로그인
    - 과정 : 원인을 찾는건 매우 쉬웠으나, 해결방안을 찾는게 어려웠음

- **<span className="text-blue-600">이번</span>  문제(API 라우트 문제)**
    - <p className="-mt-4">프론트엔드 서버가 백엔드 서버의 `Set-Cookie` 헤더를 제대로 전달하지 않음</p>
    - **로그인 성공 후에도 인증 상태가 유지되지 않음**
    - 대상 : 일반 로그인
    - 과정 : 원인을 찾는게 매우 어려웠으나, 해결방안은 간단했음

이 문서에서는 **API 라우트 변경이 로그인 인증 흐름에 미친 영향과 해결 방법**을 다룹니다.

---

### 📝 상황 설명

- 클라이언트에서 로그인 API 호출 시 정상 코드(`200 OK`)를 반환받음. (올바른 id/pw 입력 시)
- 이후 리다이렉트되는 `loginSuccess` 페이지에서 `notes`가 아니라 다시 `login` 페이지로 이동함.
- `loginSuccess` 페이지는 로그인 성공 후 **백엔드 서버에 세션 유효성 검증을 요청하는 역할**을 함.
- 즉, 백엔드가 로그인 성공이라고 판단했지만, **바로 다음 요청에서 인증 실패가 발생하는 상황** → 로그인 성공 후 로그인 실패.
- <span className="text-red-500 font-bold text-lg ml-1 mr-3">이 와중에 소셜 로그인은 잘됨</span>

---

### 🔍 원인 분석


- **키카드** : 이 문제는 보안을 강화하고자 Next.js 의 **API 라우트를 도입한 이후**에 발생한것으로 추측됨.

1. **클라이언트 요청 흐름 로깅**
      - Vercel(프론트엔드 호스팅 플랫폼) Logs를 통해 헤더를 검토한 결과,<br/>**클라이언트 요청이 프론트엔드 서버로 전송될 때는 쿠키가 정상적으로 포함됨**을 확인함.
      - 이후 프론트엔드 서버에서 백엔드 서버로 전달되는 헤더를 로깅한 결과,`Cookie` 헤더가 `undefined`로 출력됨을 포착.
      - **프론트엔드 서버 → 백엔드 서버** 과정에서 발생한 이슈인것으로 추측 범위가 축소됨.

2. **프론트엔드 요청 로깅하기**
    - 백엔드에서 반환하는 응답을 찍어보니, `Set-Cookie` 헤더가 정상적으로 포함되어 있었음.
    - 별도의 필터 로직을 추가한적이 없기 때문에  조금 혼란스러웠으나, 프론트엔드 -> 클라이언트 로깅을 진행.
    - **프론트엔드 → 클라이언트로 전달되는 과정에서 `response.data`만 반환되는 문제**를 발견.
    - 즉, API 라우트가 백엔드의 응답을 전달하는 과정에서 **쿠키 정보가 날아가버린 것**.

3. **해결방안은 간단한데, 원인을 찾는 과정이 어렵다**
    - `loginSuccess` 페이지를 통해 동일한 과정을 거치게 개선한 상태라서 소셜 로그인은 잘되는게 **오히려 헷갈리게 함**
    - 브라우저 네트워크 패널에서 응답을 비교하면서 겨우 쿠키가 사라지는곳이 API 라우트 내부였다는 사실을 찾아냄.
    - "프록시니까 응답은 당연히 그대로 반환될것이다." <br/> 라는 **고정관념을 가지는 바람에** 시야가 좁아지면서 디버깅이 늦어짐.

4. 소셜 로그인은 잘 되는 이유
    - 소셜 로그인은 클라이언트, 플랫폼, 백엔드가 API 라우트를 거치지 않고 다이렉트로 연결되는 구조이다.<br/>그래서 쿠키 전달에 성공한것

---

### 🔍 사라진건 알겠는데... 왜 `Set-Cookie`가 사라졌을까?

1. **내가 짠 프록시의 원리**
    - 요청을 받아서 **재가공하고 똑같은걸 다시 요청** 하는게 전부다. [코드 보기](https://github.com/LeeHyunWoo2/KIN-Web/blob/main/frontend/src/pages/api/proxy/%5B...path%5D.js)
    - 클라이언트가 알지 못하게 백엔드 주소를 추가하고, 프론트엔드 서버에서만 알고있는 커스텀 헤더를 추가하는 역할을 한다.
    - 요청을 다시 만들기 때문에 **따로 명시를 안하면 기존의 데이터가 온전히 보존되지 않는 구조다.**

2. **요청(Request) 헤더 (`req.headers`)**
    ```js filename="[path].js"
    const headers = {
      ...req.headers, // 클라이언트에서 보낸 헤더를 포함
      "x-api-key": process.env.CLOUDFLARE_API_TOKEN, // 추가 보안 헤더
    };
    delete headers.host; // 불필요한 host 헤더 제거
    ```
    - **여기서 실수한 부분**
    - `headers` 객체를 만들면서 **클라이언트가 보낸 요청 헤더**(`req.headers`)와 **백엔드에서 받아야 할 응답 헤더**를
    **같은 흐름에서 다룸.**
    - 즉, **클라이언트에서 받은 헤더를 그대로 백엔드에 전달하면서도, 응답을 받을 때의 헤더 처리 방식은 다르게 해야 했음.**
    - 그런데, **요청과 응답의 헤더를 따로 로깅하지 않아서 어느 시점에서 헤더가 변형되었는지 알기 어려웠음.**


3. **응답(Response) 헤더 (`res.setHeader`)...?**
    ```js filename="[path].js"
    // 백엔드 응답을 클라이언트로 전달
    res.status(response.status).json(response.data);
    ```
    > 어라 헤더가 없네...?

    <br/>

    - 낯선 로직을 짜면서 미처 생각하지 못한것이 이 부분이였다. 응답 코드가 저게 전부였다. 이런 기가막힌 이유라니!!
    - 즉, `res` 자체에는 `headers` 속성을 명시하지 않았으므로 자동 설정되는 **기본 헤더만** 포함된다.
    - 요청 코드를 작성할땐 "당연히 기존 헤더를 추가해야지" 라고 생각했는데, 조금 응용된 상황이 되니까 "당연하게" 생각하지 못했다.
    - 애꿏은 Next.js 만 검색했는데... API 라우트가 범인이 아니고 그 과정에서 짠 내 코드가 문제였던것이다...

---

### 🛠️ 해결 방안

1. **API 라우트에서 응답 헤더를 그대로 클라이언트로 전달하도록 개선**
    - 기존에는 `res.json(response.data)`로 응답을 반환했으나, 이렇게 하면 쿠키 정보가 포함되지 않음.
    - 따라서 **백엔드에서 받은 응답 헤더를 그대로 클라이언트로 전달하도록 코드 추가**.

```jsx filename="[...path].js" {1-3} copy
  Object.entries(response.headers).forEach(([key, value]) => {
    res.setHeader(key, value); // 모든 헤더를 다 추가함
  });

  res.status(response.status).send(response.data);
```

2. **수정 후 쿠키가 정상적으로 전달되는지 확인**
    - 브라우저 개발자 도구에서 로그인 후 응답을 확인하니, `Set-Cookie` 헤더가 정상적으로 전달됨.
    - 이후 요청에서도 인증 쿠키가 유지되면서 로그인 상태가 정상적으로 유지됨.

---

### ✅ 결과

- 로그인 성공 후 인증이 풀리는 문제가 해결됨.
- 반환에서도 똑같이 헤더를 전달하기 위해  `setHeader`를 사용해 헤더를 추가해서 이를 해결.

---

### 💡 배운 점

1. **요청 헤더와 응답 헤더를 따로 로깅하지 않아서 디버깅이 어려웠다.**
    - 백엔드로 요청이 갈 때 헤더가 어떻게 바뀌었는지,
    - 백엔드에서 응답을 받을 때 어떤 헤더가 포함되었는지 **바로 확인할 수 없었다.**.

2. **요청과 응답을 단일화 하여 생각하면 안된다.**
    - **요청 헤더(`headers`), 응답 헤더(`response.headers`), 그리고 최종적으로 클라이언트에 전달할 응답 헤더(`res.setHeader`)를 명확히 관리해야 한다.

3. **디버깅 과정에서 브라우저 개발자 도구(Network 탭)를 적극적으로 활용해야 한다.**
    - 로그만 확인했을 때는 문제가 보이지 않았지만,
    **네트워크 패널에서 응답 헤더를 비교하는 과정에서 원인을 찾아낼 수 있었다.**.