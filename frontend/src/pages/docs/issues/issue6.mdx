import { Callout } from 'nextra/components'

# ⛔ 이슈 6 : 로그인 성공 후 실패 - 로컬과 배포의 환경 차이

<Callout emoji="⚠️">
  이전 문서와 비슷해 보일 수 있으나, 전혀 다른 별개의 이슈입니다!!
</Callout>

두 이슈는 **모두 로그인 후 인증이 풀리거나 쿠키가 유실된다는 점에서 유사**하지만, 핵심 원인은 완전히 다릅니다.

- **<span className="text-red-600">이전</span> 문제(API 라우트 쿠키 누락)**
    - <p className="-mt-4">Next.js API 라우트에서 백엔드의 `Set-Cookie` 응답을 클라이언트로 전달하지 않아 쿠키가 증발함.</p>
    - **대상:** 일반 로그인
    - **원인:** 쿠키가 프론트엔드 서버에서 백엔드로 전달되지 않음.
    - **해결 과정:** 원인을 찾는 과정이 어려웠으나, API 라우트에서 응답 헤더를 유지하도록 변경하여 간단하게 해결됨.

- **<span className="text-blue-600">이번</span> 문제(소셜 로그인 쿠키 도메인 불일치)**
    - <p className="-mt-4">**로컬 환경에서는 문제없었으나, 배포 환경에서는 브라우저 보안 정책으로 인해 쿠키가 차단됨.**</p>
    - **대상:** **배포 환경에서의** 소셜 로그인
    - **원인:** `백엔드 주소`에서 설정한 쿠키가 `noteapp.org`에서 읽히지 않음 (도메인 불일치).
    - **해결 과정:** `Set-Cookie`의 `domain` 값을 `.noteapp.org`로 변경하여 해결.

이 문서에서는 쿠키 도메인 문제로 인해 **배포 환경에서만** 발생한 **소셜** 로그인 인증 문제를 다룹니다.

### 📝상황 설명
- 로컬 환경에서는 소셜 로그인 정상 작동 확인
- 배포 환경에서는 일반 로그인은 정상 작동하지만, 소셜 인증 전략이 정상적으로 완료된 후 세션이 유지되지 않고 로그인 화면으로 리다이렉트 됨
- 백엔드에서는 소셜 로그인 성공 후 쿠키를 설정했지만, 클라이언트에서는 세션 인증 가정에서 해당 쿠키를 서버에 전송할 수 없었음.
- 프론트엔드를 거치지 않는다는 소셜 로그인 설계의 특징 때문에 **같은 증상이 나타날리가 없다고 생각했는데** 똑같은 증상이 나타난 상황이라 더욱 헷갈림

---

### 🔍 원인 분석

1. **브라우저의 힌트**
   - 브라우저 네트워크 로그에서, 콜백 요청 후 쿠키가 보였으나 이후 요청에서는 사라짐.
   - 네트워크 요청 필터링 시 다음 메시지가 확인됨:
    > "요청 URL의 도메인이 쿠키의 도메인 속성과 정확히 일치하지 않으며,<br/> 요청 URL의 도메인이 쿠키 도메인 속성 값의 하위 도메인도 아니므로 이 쿠키가 차단되었습니다."
    - 브라우저 쿠키에는 콜백 시 토큰이 존재했으나 `loginSuccess` API 요청에서는 누락됨.

2. **도메인 불일치 문제**
    - (`백엔드 주소`)에서 `Set-Cookie`를 설정했지만, 프론트엔드(`noteapp.org`)에서는 해당 쿠키를 읽지 못함.
    - 브라우저 보안 정책상 **쿠키의 `Domain` 속성이 현재 요청하는 도메인과 일치해야 함**.
    - 일반 로그인은 `noteapp.org` 도메인에서 직접 요청하므로 쿠키가 정상 작동하지만,<br/> 소셜 로그인은 **외부 OAuth 서버를 거친 후 백엔드에서 리다이렉트되면서** 도메인 불일치 문제 발생.

3. **리버스 프록시 및 Cloudflare 설정 문제**
    - Vercel에서 API 요청을 `noteapp.org/api/proxy/` 경로로 라우팅하고 있어, 도메인 정책이 더 복잡해짐.
    - Cloudflare에서 추가적인 보안 설정이 적용되어 쿠키가 정상적으로 전달되지 않을 가능성 있음.

4. **로컬 환경에서는 문제 발생 안 함**
    - `localhost:3000` (프론트)과 `localhost:5000` (백엔드)은 서로 다른 포트를 사용하지만, 브라우저는 `localhost`를 단일 도메인으로 인식함.
    - 그래서 이전 이슈에서 소셜 로그인은 잘 된다고 "판단" 한것이었음. 배포 후 테스트했다면 서로 다른 이유로 둘 다 안됐어야 함.

5. **OAuth 콜백 URL 문제**
    - 소셜 로그인은 OAuth 서버(accounts.google.com 등)에서 인증을 거쳐 다시 백엔드 주소로 리다이렉트됨.
    - 브라우저는 리다이렉트 후 설정된 쿠키가 cross-site라고 판단하고, 보안 정책을 적용함.
    - 결과적으로 noteapp.org에서 API 요청을 보낼 때 쿠키가 누락됨.



---

### 🛠️ 해결 방안

1. **쿠키 도메인 수정**
    ```js filename="socialRoutes.js" copy
   setCookie(res, 'accessToken', tokens.accessToken,
        { maxAge: accessTokenMaxAge, domain: 'noteapp.org' });
   setCookie(res, 'refreshToken', tokens.refreshToken,
        { maxAge: refreshTokenMaxAge, domain: 'noteapp.org' });
    ```
- `Set-Cookie`의 `Domain` 속성을 `noteapp.org`로 변경하여, 하위 도메인(`백엔드 주소`)에서도 접근 가능하도록 설정함.

2. **OAuth 콜백 URL 유지 및 추가 동기화 과정 도입**
    ```js filename="socialRoutes.js" copy
    res.redirect(`${process.env.FRONTEND_ORIGIN}/loginSuccess`);
    ```
    - 기존 `백엔드 주소`로 설정된 콜백 URL을 유지하면서, 로그인 성공 후 **공통 로그인 완료 페이지(`/loginSuccess`)** 를 추가하여 클라이언트 측에서 세션을 동기화하도록 변경.

3. **브라우저에서 쿠키 정상 동작 여부 테스트**
    - 다양한 브라우저에서 쿠키 전달 여부 확인.
    - 개발자 도구에서 "요청 쿠키 제외 이유" 항목 확인하여, 브라우저 정책 위반 여부 점검.

---

### ✅ 결과

1. **쿠키 도메인 수정 후, 소셜 로그인 세션 유지 문제 해결됨.**
2. **일반 로그인과 소셜 로그인 모두 동일한 방식으로 인증 정보를 처리하도록 통합됨.**
3. **보안 정책을 유지하면서 OAuth 기반 로그인 로직이 안정적으로 동작하게 됨.**

---

### 💡 배운 점

1. **"로컬 환경에서 잘 작동한다고 해서, 배포 환경에서도 잘 작동할 것이라고 가정하면 안 된다."**
    - **도메인, 보안 정책, 브라우저 동작 방식 등 배포 환경에서의 차이를 반드시 고려해야 함.**

2. **브라우저 보안 정책을 이해하는 것이 중요함.**
    - 브라우저 개발자 도구에서 "요청 쿠키 제외 이유" 등을 적극 활용하면 문제 해결 속도가 빨라짐.